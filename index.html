<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NUMBER GO BIG</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #444;
            background: #111;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        button {
            padding: 12px 24px;
            margin: 6px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            min-width: 100px;
        }
        
        @media (max-width: 768px) {
            button {
                padding: 15px 30px;
                font-size: 16px;
                min-width: 120px;
            }
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .combine-btn {
            background: #2196F3 !important;
        }
        .combine-btn.active {
            background: #4CAF50 !important;
        }
        button.disabled {
            background: #666 !important;
            cursor: not-allowed;
        }
        button.combine-btn {
            background: #666 !important;
        }
        button.combine-btn.enabled {
            background: #4CAF50 !important;
        }
        .game-header {
            text-align: center;
            margin: 20px 0;
        }
        
        .score-challenge {
            font-size: 18px;
            font-weight: bold;
            color: white;
            margin-bottom: 8px;
        }
        
        .target-icon {
            margin-right: 8px;
        }
        
        .score-progress {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 15px;
        }
        
        .score-challenge.almost-there {
            color: #ff6b35;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        .score-challenge.getting-close {
            color: #ffa726;
        }
        
        .score-challenge.far-from-target {
            color: #ffffff;
        }
        
        .score-progress.almost-there {
            color: #ff6b35;
            font-weight: bold;
        }
        
        .score-progress.getting-close {
            color: #ffa726;
        }
        
        .score-progress.far-from-target {
            color: #ccc;
        }
        
        .hand-container {
            position: relative;
            margin: 20px auto;
            max-width: 600px;
        }
        
        .hand-label {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            color: #ccc;
            font-size: 12px;
            font-weight: bold;
            z-index: 5;
            pointer-events: none;
        }
        
        .hand {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 15px;
            transition: all 0.3s ease;
            min-height: 80px;
        }
        
        .hand.has-cards {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        /* Dynamic sizing based on card count */
        .hand:has(.number-card:nth-child(6)) {
            gap: 8px;
            padding: 12px;
        }
        
        .hand:has(.number-card:nth-child(7)) {
            gap: 6px;
            padding: 10px;
        }
        
        .hand:has(.number-card:nth-child(8)) {
            gap: 4px;
            padding: 8px;
        }
        
        .hand:has(.number-card:nth-child(9)) {
            gap: 3px;
            padding: 6px;
        }
        
        .hand:has(.number-card:nth-child(10)) {
            gap: 2px;
            padding: 4px;
        }
        .number-card {
            width: 55px;
            height: 40px;
            background: #333;
            border: 3px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            font-size: 16px;
        }
        
        @media (max-width: 768px) {
            .number-card {
                width: 45px;
                height: 35px;
                font-size: 14px;
            }
        }
        .number-card.selected {
            background: #4CAF50;
            border-color: #45a049 !important;
        }
        .number-card.common {
            border-color: #888; /* Grey for 1-3 */
        }
        .number-card.uncommon {
            border-color: #2196F3; /* Blue for 4-6 */
        }
        .number-card.rare {
            border-color: #9C27B0; /* Purple for 7-8 */
        }
        .number-card.legendary {
            border-color: #FF9800; /* Orange for 9 */
        }
        .number-card.negative {
            color: #ff4444; /* Red text for negative numbers */
        }
        .number-card.positive {
            color: #ffffff; /* White text for positive numbers */
        }
        .info {
            text-align: center;
            margin: 10px 0;
        }
        
        /* Operation display styles */
        .operation-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .fixed-card {
            width: 80px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
            color: white;
            cursor: default;
        }
        
        .operator-display {
            font-size: 32px;
            font-weight: bold;
            color: #4CAF50;
            min-width: 40px;
            text-align: center;
        }
        
        .operator-display.negative {
            color: #ff4444 !important;
        }
        
        .equals-display {
            font-size: 24px;
            font-weight: bold;
            color: #666;
            cursor: pointer;
            width: 50px;
            height: 50px;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(102, 102, 102, 0.1);
            border-radius: 50%;
            border: 2px solid #666;
        }
        
        .equals-display.ready {
            color: white;
            background: rgba(255, 255, 255, 0.1);
            border-color: white;
        }
        
        .equals-display:hover {
            transform: scale(1.1);
        }
        
        .equals-display.ready:hover {
            color: white;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .equals-display:disabled {
            color: #666;
            cursor: not-allowed;
            transform: none;
            background: rgba(102, 102, 102, 0.1);
            border-color: transparent;
        }
        
        .placeholder-card {
            width: 80px;
            height: 60px;
            background: rgba(33, 150, 243, 0.1);
            border: 3px dashed #2196F3;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            color: #666;
            font-size: 18px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .placeholder-card.drag-over {
            border-color: #1976D2;
            background: rgba(33, 150, 243, 0.2);
            transform: scale(1.05);
        }
        
        .placeholder-card.highlight {
            animation: pulse 1s infinite;
        }
        
        .placeholder-card .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ff4444;
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            min-width: 20px;
            min-height: 20px;
        }
        
        /* Dual mode styles for Round 5 */
        .dual-operation-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .dual-placeholder-card {
            width: 80px;
            height: 60px;
            background: rgba(33, 150, 243, 0.1);
            border: 3px dashed #2196F3;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            color: #666;
            font-size: 18px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .dual-placeholder-card.drag-over {
            border-color: #1976D2;
            background: rgba(33, 150, 243, 0.2);
            transform: scale(1.05);
        }
        
        .dual-placeholder-card.highlight {
            animation: pulse 1s infinite;
        }
        
        .dual-placeholder-card .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ff4444;
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            min-width: 20px;
            min-height: 20px;
        }
        
        /* Drag and drop styles */
        .combine-zone {
            width: 200px;
            height: 80px;
            border: 3px dashed #666;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px auto;
            background: rgba(102, 102, 102, 0.1);
            transition: all 0.3s ease;
        }
        
        .combine-zone.drag-over {
            border-color: #888;
            background: rgba(102, 102, 102, 0.2);
            transform: scale(1.05);
        }
        
        .combine-zone.has-cards {
            border-color: #888;
            background: rgba(102, 102, 102, 0.15);
        }
        
        .combine-zone.highlight {
            animation: pulse 1s infinite;
        }
        
        .combine-zone.used {
            background: #444 !important;
            border-color: #666 !important;
            cursor: not-allowed;
        }
        
        .combine-zone.used .combine-zone-text {
            color: #999 !important;
        }
        
        .combine-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px auto;
        }
        
        .combine-action {
            width: 50px;
            height: 50px;
            background: rgba(102, 102, 102, 0.1);
            border: 2px solid #666;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .combine-action.ready {
            background: rgba(255, 255, 255, 0.1);
            border-color: white;
        }
        
        .combine-action:hover {
            transform: scale(1.1);
        }
        
        .combine-action.ready:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .combine-action:disabled {
            cursor: not-allowed;
            transform: none;
        }
        
        .combine-icon {
            font-size: 24px;
            font-weight: bold;
            color: #666;
        }
        
        .combine-action.ready .combine-icon {
            color: white;
        }
        
        .new-label {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #666;
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            z-index: 10;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        /* Round dots styling */
        .round-dots {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .round-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            transition: all 0.3s ease;
        }
        
        .round-dot.completed {
            background: #aaaaaa;
        }
        
        .round-dot.current {
            background: #ffffff;
            animation: breathing 1.5s ease-in-out infinite;
        }
        
        @keyframes breathing {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.3);
                opacity: 0.8;
            }
        }
        
        .score-info {
            text-align: center;
            margin: 15px 0;
            color: #ccc;
            font-size: 14px;
        }
        
        .combine-zone-text {
            color: #666;
            font-size: 14px;
            text-align: center;
        }
        
        .combine-zone-text.has-cards {
            color: #2196F3;
        }
        
        .number-card.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        
        .number-card.draggable {
            cursor: grab;
        }
        
        .number-card.draggable:active {
            cursor: grabbing;
        }
        
        .number-card.touching {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        
        /* Pulse animation for drop zones */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Ghost card for touch following */
        .ghost-card {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            opacity: 0.8;
            transition: none;
        }
        
        .ghost-card.dragging {
            opacity: 0.6;
            transform: translate(-50%, -50%) rotate(5deg);
        }
        
        .combine-card {
            width: 60px;
            height: 45px;
            background: #333;
            border: 2px solid #2196F3;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            font-weight: bold;
            font-size: 16px;
            margin: 0 5px;
            position: relative;
        }
        
        .combine-card .remove-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ff4444;
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            min-width: 20px;
            min-height: 20px;
        }
        
        @media (max-width: 768px) {
            .fixed-card, .placeholder-card, .dual-placeholder-card {
                width: 60px;
                height: 45px;
                font-size: 18px;
            }
            
            .operator-display {
                font-size: 24px;
            }
            
            .combine-zone {
                width: 160px;
                height: 60px;
            }
        }
    </style>
</head>
<body>
    <h1>NUMBER GO BIG</h1>
    <div class="info">
        <div class="round-dots" id="roundDots">
            <!-- Round dots will be generated here -->
        </div>
    </div>
    
    <div class="game-header">
        <div class="score-challenge">
            Score <span id="targetScore">300</span> to win. One new number every round.
        </div>
    </div>
    
    <div class="operation-display" id="operationDisplay">
        <div class="fixed-card" id="fixedCard">10</div>
        <div class="operator-display" id="operatorDisplay">+</div>
        <div class="placeholder-card" id="placeholderCard">...</div>
        <div class="equals-display" id="equalsDisplay">=</div>
    </div>
    
    <div class="dual-operation-display" id="dualOperationDisplay" style="display: none;">
        <div class="fixed-card" id="dualFixedCard">10</div>
        <div class="operator-display" id="dualOperatorDisplay1">+</div>
        <div class="dual-placeholder-card" id="dualPlaceholderCard1">...</div>
        <div class="operator-display" id="dualOperatorDisplay2">+</div>
        <div class="dual-placeholder-card" id="dualPlaceholderCard2">...</div>
        <div class="equals-display" id="dualEqualsDisplay">=</div>
    </div>
    
    <div class="hand-container">
        <div class="hand" id="hand">
            <div class="hand-label">Your numbers</div>
            <!-- Numbers will be generated here -->
        </div>
    </div>
    
    
    <div class="combine-container">
        <div class="combine-zone" id="combineZone">
            <div class="combine-zone-text" id="combineZoneText">Combine two numbers</div>
        </div>
        <div class="combine-action" id="combineAction">
            <div class="combine-icon">+</div>
        </div>
    </div>
    
    <div id="gameOver" style="display: none; text-align: center; margin-top: 20px;">
        <h2 style="margin-bottom: 20px;">Game Over!</h2>
        <div style="margin-bottom: 15px;">Final Score: <span id="finalScore">0</span></div>
        <div id="result" style="margin-bottom: 25px;"></div>
        <button onclick="restartGame()">Restart</button>
    </div>
    
    <div style="text-align: center; margin-top: 30px; color: #666; font-size: 14px;">
        Created by Alex Lorenzo<br>
        v0.6
    </div>

    <script>
        // Game state
        let gameState = {
            round: 1,
            maxRounds: 10,
            availableNumbers: [
                {id: 'card-1', value: 1},
                {id: 'card-2', value: 2},
                {id: 'card-3', value: 3},
                {id: 'card-4', value: 4},
                {id: 'card-5', value: 5}
            ],
            currentResult: 10,
            currentOperator: '+',
            selectedNumber: null,
            gamePhase: 'playing',
            targetScore: 300,
            dualMode: false,
            secondOperator: '',
            selectedNumbers: [],
            selectedForCombination: [],
            combinationUsed: false,
            combineZoneCards: [],
            newestCardId: null
        };

        function getNumberRarity(number) {
            const absNumber = Math.abs(number);
            if (absNumber <= 3) return 'common';
            if (absNumber <= 6) return 'uncommon';
            if (absNumber <= 8) return 'rare';
            return 'legendary';
        }
        
        function getRarityBorderColor(rarity) {
            switch(rarity) {
                case 'common': return '#888'; // Grey
                case 'uncommon': return '#2196F3'; // Blue
                case 'rare': return '#9C27B0'; // Purple
                case 'legendary': return '#FF9800'; // Orange
                default: return '#888';
            }
        }

        function generateRandomOperator() {
            const operators = ['+', '-', '*', '/'];
            return operators[Math.floor(Math.random() * operators.length)];
        }

        function generateRandomNumber() {
            let rand = Math.random() * 100;
            let number;
            
            if (rand <= 60) {
                number = Math.floor(Math.random() * 3) + 1;
            } else if (rand <= 85) {
                number = Math.floor(Math.random() * 3) + 4;
            } else if (rand <= 97) {
                number = Math.floor(Math.random() * 2) + 7;
            } else {
                number = 9;
            }
            
            if (Math.random() < 0.5) {
                number = -number;
            }
            
            return {
                id: 'card-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                value: number
            };
        }

        function calculateResult(left, operator, right) {
            let result;
            switch(operator) {
                case '+': result = left + right; break;
                case '-': result = left - right; break;
                case '*': result = left * right; break;
                case '/': 
                    if (right === 0) return 0;
                    result = left / right; 
                    break;
            }
            return Math.ceil(result);
        }

        function updateRoundDots() {
            const roundDots = document.getElementById('roundDots');
            roundDots.innerHTML = '';
            
            for (let i = 1; i <= 10; i++) {
                const dot = document.createElement('div');
                dot.className = 'round-dot';
                
                if (i < gameState.round) {
                    dot.classList.add('completed');
                } else if (i === gameState.round) {
                    dot.classList.add('current');
                }
                
                roundDots.appendChild(dot);
            }
        }
        
        function updateScoreProgress() {
            const currentScore = Math.ceil(gameState.currentResult);
            const targetScore = gameState.targetScore;
            const pointsNeeded = targetScore - currentScore;
            
            // Update target score display
            document.getElementById('targetScore').textContent = targetScore;
            
            // Add visual feedback based on progress
            const scoreChallenge = document.querySelector('.score-challenge');
            
            // Remove existing classes
            scoreChallenge.classList.remove('almost-there', 'getting-close', 'far-from-target');
            
            if (pointsNeeded <= 50) {
                scoreChallenge.classList.add('almost-there');
            } else if (pointsNeeded <= 100) {
                scoreChallenge.classList.add('getting-close');
            } else {
                scoreChallenge.classList.add('far-from-target');
            }
        }

        function updateDisplay() {
            // Update round dots
            updateRoundDots();
            
            // Update score progress
            updateScoreProgress();
            
            if (gameState.gamePhase === 'game_over') {
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('finalScore').textContent = Math.ceil(gameState.currentResult);
                if (gameState.currentResult >= gameState.targetScore) {
                    document.getElementById('result').textContent = 'Congratulations! You reached the target!';
                } else {
                    document.getElementById('result').textContent = `You need ${Math.ceil(gameState.targetScore - gameState.currentResult)} more points to win!`;
                }
                
                // Hide combine functionality when game is over
                document.getElementById('combineZone').style.display = 'none';
                document.getElementById('combineAction').style.display = 'none';
                
                // Hide equals signs when game is over
                document.getElementById('equalsDisplay').style.display = 'none';
                document.getElementById('dualEqualsDisplay').style.display = 'none';
                
                return;
            }

            // Update operation display
            updateOperationDisplay();
            
            // Show/hide appropriate operation display
            const operationDisplay = document.getElementById('operationDisplay');
            const dualOperationDisplay = document.getElementById('dualOperationDisplay');
            
            if (gameState.dualMode) {
                // Show dual operation display
                operationDisplay.style.display = 'none';
                dualOperationDisplay.style.display = 'flex';
                updateDualOperationDisplay();
            } else {
                // Show normal operation display
                operationDisplay.style.display = 'flex';
                dualOperationDisplay.style.display = 'none';
            }
            
            // Update combine zone
            updateCombineZone();

            // Always show both buttons
            const equalsDisplay = document.getElementById('equalsDisplay');
            const dualEqualsDisplay = document.getElementById('dualEqualsDisplay');
            const combineAction = document.getElementById('combineAction');

            // Equals sign logic
            if (gameState.dualMode) {
                // In dual mode: enabled when exactly 2 numbers selected
                const validCards = gameState.selectedNumbers.filter(card => card !== null && card !== undefined);
                console.log('Dual mode validation:', {
                    selectedNumbers: gameState.selectedNumbers,
                    validCards: validCards,
                    validCardsLength: validCards.length
                });
                if (validCards.length === 2) {
                    dualEqualsDisplay.disabled = false;
                    dualEqualsDisplay.classList.add('ready');
                } else {
                    dualEqualsDisplay.disabled = true;
                    dualEqualsDisplay.classList.remove('ready');
                }
                // Combine action logic in dual mode - enabled when exactly 2 numbers in combine zone
                if (!gameState.combinationUsed && gameState.combineZoneCards.length === 2) {
                    combineAction.disabled = false;
                    combineAction.classList.add('ready');
                } else {
                    combineAction.disabled = true;
                    combineAction.classList.remove('ready');
                }
            } else {
                // Normal mode: enabled when exactly 1 number selected for play
                if (gameState.selectedNumber !== null && gameState.selectedForCombination.length === 0) {
                    equalsDisplay.disabled = false;
                    equalsDisplay.classList.add('ready');
                } else {
                    equalsDisplay.disabled = true;
                    equalsDisplay.classList.remove('ready');
                }

                // Combine action logic - enabled when exactly 2 numbers in combine zone
                if (!gameState.combinationUsed && gameState.combineZoneCards.length === 2) {
                    combineAction.disabled = false;
                    combineAction.classList.add('ready');
                } else {
                    combineAction.disabled = true;
                    combineAction.classList.remove('ready');
                }
            }
        }
        
        function updateOperationDisplay() {
            const fixedCard = document.getElementById('fixedCard');
            const operatorDisplay = document.getElementById('operatorDisplay');
            const placeholderCard = document.getElementById('placeholderCard');
            
            // Update fixed card with current result
            fixedCard.textContent = Math.ceil(gameState.currentResult);
            
            // Convert operator symbols
            let operatorSymbol = gameState.currentOperator;
            if (operatorSymbol === '*') operatorSymbol = '×';
            if (operatorSymbol === '/') operatorSymbol = '÷';
            if (operatorSymbol === '-') operatorSymbol = '−';
            
            operatorDisplay.textContent = operatorSymbol;
            
            // Apply red color for negative operators
            if (gameState.currentOperator === '-' || gameState.currentOperator === '/') {
                operatorDisplay.classList.add('negative');
            } else {
                operatorDisplay.classList.remove('negative');
            }
            
            // Clear existing remove button
            const existingRemoveBtn = placeholderCard.querySelector('.remove-btn');
            if (existingRemoveBtn) {
                existingRemoveBtn.remove();
            }
            
            // Update placeholder based on selection
            if (gameState.dualMode) {
                if (gameState.selectedNumbers.length >= 1) {
                    const firstNumber = gameState.availableNumbers[gameState.selectedNumbers[0]];
                    placeholderCard.textContent = firstNumber;
                    placeholderCard.style.background = '#4CAF50';
                    placeholderCard.style.borderColor = '#45a049';
                } else {
                    placeholderCard.textContent = '...';
                    placeholderCard.style.background = '#333';
                    placeholderCard.style.borderColor = '#666';
                }
            } else {
                if (gameState.selectedNumber !== null) {
                    // selectedNumber is now a card object
                    placeholderCard.textContent = gameState.selectedNumber.value;
                    placeholderCard.style.background = '#333';
                    const rarity = getNumberRarity(gameState.selectedNumber.value);
                    placeholderCard.style.borderColor = getRarityBorderColor(rarity);
                    placeholderCard.style.color = '#ffffff'; // White text like original cards
                    placeholderCard.style.borderStyle = 'solid'; // Solid border instead of dashed
                    
                    // Add remove button
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.textContent = '×';
                    removeBtn.onclick = removeFromPlayZone;
                    placeholderCard.appendChild(removeBtn);
                } else {
                    placeholderCard.textContent = '...';
                    placeholderCard.style.background = '#333';
                    placeholderCard.style.borderColor = '#666';
                }
            }
            
            // Make placeholder card droppable
            placeholderCard.draggable = false;
            placeholderCard.addEventListener('dragover', handleDragOver);
            placeholderCard.addEventListener('dragleave', handleDragLeave);
            placeholderCard.addEventListener('drop', handlePlaceholderDrop);
        }
        
        function updateDualOperationDisplay() {
            const dualFixedCard = document.getElementById('dualFixedCard');
            const dualOperatorDisplay1 = document.getElementById('dualOperatorDisplay1');
            const dualOperatorDisplay2 = document.getElementById('dualOperatorDisplay2');
            const dualPlaceholderCard1 = document.getElementById('dualPlaceholderCard1');
            const dualPlaceholderCard2 = document.getElementById('dualPlaceholderCard2');
            
            // Update fixed card with current result
            dualFixedCard.textContent = Math.ceil(gameState.currentResult);
            
            // Convert operator symbols
            let operatorSymbol1 = gameState.currentOperator;
            if (operatorSymbol1 === '*') operatorSymbol1 = '×';
            if (operatorSymbol1 === '/') operatorSymbol1 = '÷';
            if (operatorSymbol1 === '-') operatorSymbol1 = '−';
            
            let operatorSymbol2 = gameState.secondOperator;
            if (operatorSymbol2 === '*') operatorSymbol2 = '×';
            if (operatorSymbol2 === '/') operatorSymbol2 = '÷';
            if (operatorSymbol2 === '-') operatorSymbol2 = '−';
            
            dualOperatorDisplay1.textContent = operatorSymbol1;
            dualOperatorDisplay2.textContent = operatorSymbol2;
            
            // Apply red color for negative operators
            if (gameState.currentOperator === '-' || gameState.currentOperator === '/') {
                dualOperatorDisplay1.classList.add('negative');
            } else {
                dualOperatorDisplay1.classList.remove('negative');
            }
            
            if (gameState.secondOperator === '-' || gameState.secondOperator === '/') {
                dualOperatorDisplay2.classList.add('negative');
            } else {
                dualOperatorDisplay2.classList.remove('negative');
            }
            
            // Update first placeholder
            updateDualPlaceholder(dualPlaceholderCard1, 0);
            // Update second placeholder
            updateDualPlaceholder(dualPlaceholderCard2, 1);
            
            // Make placeholder cards droppable - ensure they're properly set up
            setupDualPlaceholderDrop(dualPlaceholderCard1, 0);
            setupDualPlaceholderDrop(dualPlaceholderCard2, 1);
        }
        
        function updateDualPlaceholder(placeholderCard, index) {
            // Clear existing remove button
            const existingRemoveBtn = placeholderCard.querySelector('.remove-btn');
            if (existingRemoveBtn) {
                existingRemoveBtn.remove();
            }
            
            if (gameState.selectedNumbers.length > index && gameState.selectedNumbers[index] !== null) {
                // In dual mode, selectedNumbers contains card objects
                const cardObj = gameState.selectedNumbers[index];
                placeholderCard.textContent = cardObj.value;
                placeholderCard.style.background = '#333';
                const rarity = getNumberRarity(cardObj.value);
                placeholderCard.style.borderColor = getRarityBorderColor(rarity);
                placeholderCard.style.color = '#ffffff';
                placeholderCard.style.borderStyle = 'solid';
                
                // Add remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = '×';
                removeBtn.onclick = () => removeFromDualPlayZone(index);
                placeholderCard.appendChild(removeBtn);
            } else {
                placeholderCard.textContent = '...';
                placeholderCard.style.background = '#333';
                placeholderCard.style.borderColor = '#666';
                placeholderCard.style.borderStyle = 'dashed';
            }
        }
        
        function setupDualPlaceholderDrop(placeholderCard, index) {
            placeholderCard.draggable = false;
            
            // Remove existing listeners to avoid duplicates
            placeholderCard.removeEventListener('dragover', handleDragOver);
            placeholderCard.removeEventListener('dragleave', handleDragLeave);
            placeholderCard.removeEventListener('drop', handleDualPlaceholderDrop);
            placeholderCard.removeEventListener('touchstart', handleDualTouchStart);
            placeholderCard.removeEventListener('touchmove', handleDualTouchMove);
            placeholderCard.removeEventListener('touchend', handleDualTouchEnd);
            
            // Add event listeners directly to the element
            placeholderCard.addEventListener('dragover', handleDragOver);
            placeholderCard.addEventListener('dragleave', handleDragLeave);
            placeholderCard.addEventListener('drop', (e) => handleDualPlaceholderDrop(e, index));
            
            // Add touch support
            placeholderCard.addEventListener('touchstart', (e) => handleDualTouchStart(e, index));
            placeholderCard.addEventListener('touchmove', (e) => handleDualTouchMove(e));
            placeholderCard.addEventListener('touchend', (e) => handleDualTouchEnd(e, index));
        }
        
        function handleDualPlaceholderDrop(e, index) {
            e.preventDefault();
            e.target.classList.remove('drag-over');
            
            const cardId = e.dataTransfer.getData('card/id');
            const cardIndex = gameState.availableNumbers.findIndex(card => card.id === cardId);
            const cardObj = gameState.availableNumbers[cardIndex];
            
            if (!cardObj || cardIndex === -1) return;
            
            // If there's already a card in this slot, return it to the hand first
            if (gameState.selectedNumbers[index] !== null && gameState.selectedNumbers[index] !== undefined) {
                gameState.availableNumbers.push(gameState.selectedNumbers[index]);
            }
            
            // Remove from hand first
            gameState.availableNumbers.splice(cardIndex, 1);
            
            // Add to dual selection - store the card object
            if (gameState.selectedNumbers.length <= index) {
                // Fill in missing slots
                while (gameState.selectedNumbers.length <= index) {
                    gameState.selectedNumbers.push(null);
                }
            }
            gameState.selectedNumbers[index] = cardObj;
            
            updateDisplay();
            renderHand();
        }
        
        function removeFromDualPlayZone(index) {
            if (gameState.selectedNumbers[index] !== null) {
                // Return the card to the hand
                gameState.availableNumbers.push(gameState.selectedNumbers[index]);
                // Clear selection
                gameState.selectedNumbers[index] = null;
                updateDisplay();
                renderHand();
            }
        }
        
        function handlePlaceholderDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');
            
            const index = parseInt(e.dataTransfer.getData('text/plain'));
            const cardObj = gameState.availableNumbers[index];
            
            // If there's already a selected number, return it to the hand first
            if (gameState.selectedNumber !== null) {
                gameState.availableNumbers.push(gameState.selectedNumber);
            }
            
            // Remove from hand first
            gameState.availableNumbers.splice(index, 1);
            
            // Select the number for play
            if (gameState.dualMode) {
                // Adjust indices for remaining cards in dual mode
                gameState.selectedNumbers = gameState.selectedNumbers.map(selectedIndex => {
                    if (selectedIndex > index) {
                        return selectedIndex - 1;
                    }
                    return selectedIndex;
                });
                
                if (!gameState.selectedNumbers.includes(index) && gameState.selectedNumbers.length < 2) {
                    gameState.selectedNumbers.push(index);
                }
            } else {
                // For normal mode, we need to track the selected number differently
                // since we removed it from availableNumbers
                gameState.selectedNumber = cardObj; // Store the card object instead of just the number
            }
            
            updateDisplay();
            renderHand();
        }
        
        function updateCombineZone() {
            const combineZone = document.getElementById('combineZone');
            const combineZoneText = document.getElementById('combineZoneText');
            
            // Clear existing cards
            const existingCards = combineZone.querySelectorAll('.combine-card');
            existingCards.forEach(card => card.remove());
            
            // Check if combine has been used this round
            if (gameState.combinationUsed) {
                combineZoneText.style.display = 'block';
                combineZoneText.textContent = 'Combine Used (resets next round)';
                combineZone.classList.add('used');
                combineZone.classList.remove('has-cards');
                return;
            }
            
            if (gameState.combineZoneCards.length === 0) {
                combineZoneText.style.display = 'block';
                combineZoneText.textContent = 'Combine two numbers';
                combineZone.classList.remove('has-cards', 'used');
            } else {
                combineZoneText.style.display = 'none';
                combineZone.classList.add('has-cards');
                combineZone.classList.remove('used');
                
                // Add cards to combine zone
                gameState.combineZoneCards.forEach((cardData, index) => {
                    const card = document.createElement('div');
                    card.className = 'combine-card';
                    card.textContent = cardData.number;
                    card.dataset.index = index;
                    
                    // Add rarity styling
                    const rarity = getNumberRarity(cardData.number);
                    card.classList.add(rarity);
                    
                    if (cardData.number < 0) {
                        card.classList.add('negative');
                    } else {
                        card.classList.add('positive');
                    }
                    
                    // Add remove button
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.textContent = '×';
                    removeBtn.onclick = () => removeFromCombineZone(index);
                    card.appendChild(removeBtn);
                    
                    combineZone.appendChild(card);
                });
            }
        }

        function renderHand() {
            const hand = document.getElementById('hand');
            hand.innerHTML = '';
            
            // Add has-cards class if there are cards
            if (gameState.availableNumbers.length > 0) {
                hand.classList.add('has-cards');
            } else {
                hand.classList.remove('has-cards');
            }
            
            gameState.availableNumbers.forEach((cardObj, index) => {
                const card = document.createElement('div');
                card.className = 'number-card draggable';
                card.textContent = cardObj.value;
                card.dataset.index = index;
                card.dataset.cardId = cardObj.id;
                card.draggable = true;
                
                // Add rarity class
                const rarity = getNumberRarity(cardObj.value);
                card.classList.add(rarity);
                
                // Add positive/negative class
                if (cardObj.value < 0) {
                    card.classList.add('negative');
                } else {
                    card.classList.add('positive');
                }
                
                // Add "new" label to the newest card
                if (gameState.newestCardId === cardObj.id) {
                    const newLabel = document.createElement('div');
                    newLabel.className = 'new-label';
                    newLabel.textContent = 'new';
                    card.style.position = 'relative';
                    card.appendChild(newLabel);
                }
                
                // Check if selected (only for dual mode and combination mode)
                let isSelected = false;
                if (gameState.dualMode) {
                    isSelected = gameState.selectedNumbers.includes(index);
                } else if (gameState.selectedForCombination.includes(index)) {
                    isSelected = true;
                }
                // Note: Removed green highlighting for normal play selection

                if (isSelected) {
                    card.classList.add('selected');
                }
                
                // Add drag and drop event listeners
                card.addEventListener('dragstart', handleDragStart);
                card.addEventListener('dragend', handleDragEnd);
                // Removed click functionality - only drag and drop allowed
                
                // Add touch event listeners for mobile
                card.addEventListener('touchstart', handleTouchStart);
                card.addEventListener('touchmove', handleTouchMove);
                card.addEventListener('touchend', handleTouchEnd);
                
                hand.appendChild(card);
            });
        }

        // selectNumber function removed - only drag and drop allowed
        
        // Drag and drop handlers
        function handleDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
            e.dataTransfer.setData('text/plain', e.target.dataset.index);
            // Store the card ID for reliable identification
            e.dataTransfer.setData('card/id', e.target.dataset.cardId);
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.target.classList.add('drag-over');
        }
        
        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');
            
            const index = parseInt(e.dataTransfer.getData('text/plain'));
            const cardObj = gameState.availableNumbers[index];
            
            // Check if card is already in combine zone by comparing the card ID
            const alreadyInZone = gameState.combineZoneCards.some(card => card.cardId === cardObj.id);
            if (alreadyInZone) return;
            
            // Add to combine zone if not full
            if (gameState.combineZoneCards.length < 2) {
                gameState.combineZoneCards.push({
                    number: cardObj.value,
                    cardId: cardObj.id,
                    originalIndex: index
                });
                
                // Remove from hand for visual feedback
                gameState.availableNumbers.splice(index, 1);
                
                // Adjust indices for remaining cards in combine zone
                gameState.combineZoneCards.forEach(card => {
                    if (card.originalIndex > index) {
                        card.originalIndex--;
                    }
                });
                
                updateDisplay();
                renderHand();
            }
        }
        
        function removeFromCombineZone(index) {
            const cardToReturn = gameState.combineZoneCards[index];
            // Return the card to the hand as a card object
            gameState.availableNumbers.push({
                id: 'card-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                value: cardToReturn.number
            });
            // Remove from combine zone
            gameState.combineZoneCards.splice(index, 1);
            updateDisplay();
            renderHand();
        }
        
        function removeFromPlayZone() {
            if (gameState.selectedNumber !== null) {
                // Return the card to the hand
                gameState.availableNumbers.push(gameState.selectedNumber);
                // Clear selection
                gameState.selectedNumber = null;
                updateDisplay();
                renderHand();
            }
        }
        
        // Touch event handlers for mobile
        function handleTouchStart(e) {
            e.preventDefault();
            e.target.classList.add('touching');
            
            // Create ghost card
            const ghostCard = e.target.cloneNode(true);
            ghostCard.classList.add('ghost-card');
            ghostCard.classList.add('dragging');
            document.body.appendChild(ghostCard);
            
            // Store reference for cleanup
            e.target.ghostCard = ghostCard;
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (e.target.ghostCard) {
                const touch = e.touches[0];
                e.target.ghostCard.style.left = touch.clientX + 'px';
                e.target.ghostCard.style.top = touch.clientY + 'px';
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            e.target.classList.remove('touching');
            
            // Remove ghost card
            if (e.target.ghostCard) {
                document.body.removeChild(e.target.ghostCard);
                e.target.ghostCard = null;
            }
            
            // Check if touching a drop zone
            const touch = e.changedTouches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (elementBelow && elementBelow.closest('.combine-zone')) {
                // Add to combine zone
                const index = parseInt(e.target.dataset.index);
                handleCombineZoneTouch(index);
            } else if (elementBelow && elementBelow.closest('.placeholder-card')) {
                // Add to play zone
                const index = parseInt(e.target.dataset.index);
                handlePlayZoneTouch(index);
            }
        }
        
        function handleCombineZoneTouch(index) {
            const cardObj = gameState.availableNumbers[index];
            
            // Check if card is already in combine zone by comparing the card ID
            const alreadyInZone = gameState.combineZoneCards.some(card => card.cardId === cardObj.id);
            if (alreadyInZone) return;
            
            // Add to combine zone if not full
            if (gameState.combineZoneCards.length < 2) {
                gameState.combineZoneCards.push({
                    number: cardObj.value,
                    cardId: cardObj.id,
                    originalIndex: index
                });
                
                // Remove from hand
                gameState.availableNumbers.splice(index, 1);
                
                // Adjust indices for remaining cards in combine zone
                gameState.combineZoneCards.forEach(card => {
                    if (card.originalIndex > index) {
                        card.originalIndex--;
                    }
                });
                
                updateDisplay();
                renderHand();
            }
        }
        
        function handlePlayZoneTouch(index) {
            const cardObj = gameState.availableNumbers[index];
            
            if (gameState.selectedNumber === null) {
                // Remove from hand first
                gameState.availableNumbers.splice(index, 1);
                
                // Select the number for play
                gameState.selectedNumber = cardObj;
                
                updateDisplay();
                renderHand();
            }
        }
        
        // Touch event handlers for dual placeholders
        function handleDualTouchStart(e, index) {
            e.preventDefault();
            e.target.classList.add('highlight');
        }
        
        function handleDualTouchMove(e) {
            e.preventDefault();
        }
        
        function handleDualTouchEnd(e, index) {
            e.preventDefault();
            e.target.classList.remove('highlight');
            
            // Check if touching a card from the hand
            const touch = e.changedTouches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (elementBelow && elementBelow.classList.contains('number-card')) {
                const cardId = elementBelow.dataset.cardId;
                const cardIndex = gameState.availableNumbers.findIndex(card => card.id === cardId);
                const cardObj = gameState.availableNumbers[cardIndex];
                
                if (cardObj && cardIndex !== -1) {
                    // If there's already a card in this slot, return it to the hand first
                    if (gameState.selectedNumbers[index] !== null && gameState.selectedNumbers[index] !== undefined) {
                        gameState.availableNumbers.push(gameState.selectedNumbers[index]);
                    }
                    
                    // Remove from hand first
                    gameState.availableNumbers.splice(cardIndex, 1);
                    
                    // Add to dual selection - store the card object
                    if (gameState.selectedNumbers.length <= index) {
                        // Fill in missing slots
                        while (gameState.selectedNumbers.length <= index) {
                            gameState.selectedNumbers.push(null);
                        }
                    }
                    gameState.selectedNumbers[index] = cardObj;
                    
                    updateDisplay();
                    renderHand();
                }
            }
        }

        function playTurn() {
            if (gameState.dualMode) {
                // Get the two selected cards (filter out null and undefined values)
                const selectedCards = gameState.selectedNumbers.filter(card => card !== null && card !== undefined);
                if (selectedCards.length === 2) {
                    const firstResult = calculateResult(gameState.currentResult, gameState.currentOperator, selectedCards[0].value);
                    const finalResult = calculateResult(firstResult, gameState.secondOperator, selectedCards[1].value);
                    gameState.currentResult = finalResult;
                }
                
                // Clear selected numbers
                gameState.selectedNumbers = [];
            } else {
                const result = calculateResult(gameState.currentResult, gameState.currentOperator, gameState.selectedNumber.value);
                gameState.currentResult = result;
                
                // selectedNumber is already removed from availableNumbers when dragged
                gameState.selectedNumber = null;
            }
            
            // Add new number
            const newCard = generateRandomNumber();
            gameState.availableNumbers.push(newCard);
            gameState.newestCardId = newCard.id;
            nextRound();
        }

        function nextRound() {
            gameState.round++;
            gameState.combinationUsed = false;
            
            if (gameState.round > gameState.maxRounds) {
                gameState.gamePhase = 'game_over';
            } else {
                if (gameState.round === 5) {
                    gameState.dualMode = true;
                    gameState.currentOperator = generateRandomOperator();
                    gameState.secondOperator = generateRandomOperator();
                } else {
                    gameState.dualMode = false;
                    gameState.currentOperator = generateRandomOperator();
                }
            }
            updateDisplay();
            renderHand();
        }

        function executeCombination() {
            if (gameState.combineZoneCards.length === 2) {
                const result = gameState.combineZoneCards[0].number + gameState.combineZoneCards[1].number;
                
                // Add combination result (original cards already removed from hand when dragged)
                const newCombinedCard = {
                    id: 'card-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                    value: result
                };
                gameState.availableNumbers.push(newCombinedCard);
                gameState.newestCardId = newCombinedCard.id;
                gameState.combinationUsed = true;
                gameState.combineZoneCards = [];
            }
            updateDisplay();
            renderHand();
        }

        function restartGame() {
            gameState = {
                round: 1,
                maxRounds: 10,
                availableNumbers: [
                    {id: 'card-1', value: 1},
                    {id: 'card-2', value: 2},
                    {id: 'card-3', value: 3},
                    {id: 'card-4', value: 4},
                    {id: 'card-5', value: 5}
                ],
                currentResult: 10,
                currentOperator: generateRandomOperator(),
                selectedNumber: null,
                gamePhase: 'playing',
                targetScore: 300,
                dualMode: false,
                secondOperator: '',
                selectedNumbers: [],
                selectedForCombination: [],
                combinationUsed: false,
                combineZoneCards: [],
                newestCardId: null
            };
            document.getElementById('gameOver').style.display = 'none';
            
            // Show combine functionality when restarting game
            document.getElementById('combineZone').style.display = 'flex';
            document.getElementById('combineAction').style.display = 'flex';
            
            // Show equals signs when restarting game
            document.getElementById('equalsDisplay').style.display = 'flex';
            document.getElementById('dualEqualsDisplay').style.display = 'flex';
            
            updateDisplay();
            renderHand();
        }

        // Event listeners
        document.getElementById('equalsDisplay').onclick = playTurn;
        document.getElementById('dualEqualsDisplay').onclick = playTurn;
        document.getElementById('combineAction').onclick = () => {
            // Only execute if 2 numbers are in combine zone
            if (gameState.combineZoneCards.length === 2) {
                executeCombination();
            }
        };
        
        // Set up combine zone drag and drop
        const combineZone = document.getElementById('combineZone');
        combineZone.addEventListener('dragover', handleDragOver);
        combineZone.addEventListener('dragleave', handleDragLeave);
        combineZone.addEventListener('drop', handleDrop);
        
        // Add touch event listeners to drop zones
        combineZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            combineZone.classList.add('highlight');
        });
        
        combineZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            // Keep the highlight during movement
        });
        
        combineZone.addEventListener('touchend', (e) => {
            e.preventDefault();
            combineZone.classList.remove('highlight');
        });
        
        // Add touch support for placeholder card
        const placeholderCard = document.getElementById('placeholderCard');
        placeholderCard.addEventListener('touchstart', (e) => {
            e.preventDefault();
            placeholderCard.classList.add('highlight');
        });
        
        placeholderCard.addEventListener('touchmove', (e) => {
            e.preventDefault();
            // Keep the highlight during movement
        });
        
        placeholderCard.addEventListener('touchend', (e) => {
            e.preventDefault();
            placeholderCard.classList.remove('highlight');
        });

        // Initialize game
        gameState.currentOperator = generateRandomOperator();
        updateDisplay();
        renderHand();
    </script>
</body>
</html>
